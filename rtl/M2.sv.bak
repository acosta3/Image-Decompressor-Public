
`timescale 1ns/100ps
`ifndef DISABLE_DEFAULT_NET
`default_nettype none
`endif

`include "define_state.h"


// It connects the UART, SRAM and VGA together.
// It gives access to the SRAM for UART and VGA
module M2 (
    input logic Clock_50,
	 input logic Resetn,
	 input logic [15:0]SRAM_read_data,
	 input logic M2_start,
	 
	 output logic SRAM_we_n,
    output logic M2_done,
	 output logic  [15:0] SRAM_write_data,
	 output logic [17:0] SRAM_address

);


M2_state_type M2_state;

parameter Y_base_address = 18'd76800;

// T

logic signed [32:0] T_0,T_1,T_2,T_3,T_2_BUF, T_3_BUF;
logic signed [32:0] S_0,S_1,S_2,S_3,S_2_BUF, S_3_BUF;



//multipliers 

//multiplier params
logic signed[31:0] Mult_M2_op_0_1, Mult_M2_op_0_2, Mult_M2_result_0;
logic signed[63:0] Mult_M2_result_long_0;
logic signed[31:0] Mult_M2_op_1_1, Mult_M2_op_1_2, Mult_M2_result_1;
logic signed[63:0] Mult_M2_result_long_1;
logic signed[31:0] Mult_M2_op_2_1, Mult_M2_op_2_2, Mult_M2_result_2;
logic signed[63:0] Mult_M2_result_long_2;
logic signed[31:0] Mult_M2_op_3_1, Mult_M2_op_3_2, Mult_M2_result_3;
logic signed[63:0] Mult_M2_result_long_3;

///memory addressing for DPRAM 32 bit write and 7 bit addressing

logic unsigned [6:0] address_s_prime_0, address_s_prime_1, address_T_0, address_T_1, address_S_0, address_S_1;
logic unsigned [31:0] write_s_prime_0, write_s_prime_1, write_T_0, write_T_1,write_S_0,write_S_1;
logic unsigned WE_s_prime_0,WE_s_prime_1,WE_T_0,WE_T_1,WE_S_0,WE_S_1;
logic [31:0] read_data_s_prime_0,read_data_s_prime_1,read_data_T_0,read_data_T_1,read_data_S_0,read_data_S_1;
			 

			 
// counters
// sample counter = 6 bit signal
// row_index,col_index = 3 bits signals 
logic [5:0] Sample_counter;
logic [2:0] row_index;
logic [2:0] col_index;
logic [6:0] column_block;
logic [5:0] row_block;








// coefficient matrix wires

logic[5:0] c_index_0,c_index_1,c_index_2,c_index_3;
logic[3:0] mux_counter;
// C matrix counters
logic signed [31:0] C0,C1,C2,C3;
logic [7:0] C_multiplier_row, C_multiplier_column;


logic flag_increment_row;
logic FS_CC_transition;
// RAM 0 = RAM S'
dual_port_RAM0 RAM_inst0 (
	.address_a ( address_s_prime_0 ),
	.address_b ( address_s_prime_1 ),
	.clock ( Clock_50 ),
	.data_a ( write_s_prime_0 ),
	.data_b ( write_s_prime_1 ),
	.wren_a ( WE_s_prime_0 ),
	.wren_b ( WE_s_prime_1 ),
	.q_a ( read_data_s_prime_0 ),
	.q_b ( read_data_s_prime_1 )
   );
// RAM 1 = RAM T
dual_port_RAM1 RAM_inst1 (
	.address_a ( address_T_0 ),
	.address_b ( address_T_1 ),
	.clock ( Clock_50 ),
	.data_a ( write_T_0 ),
	.data_b ( write_T_1 ),
	.wren_a ( WE_T_0 ),
	.wren_b ( WE_T_1 ),
	.q_a ( read_data_T_0 ),
	.q_b ( read_data_T_1 )
	);
	
// RAM 1 = RAM S
dual_port_RAM2 RAM_inst2 (
	.address_a ( address_S_0 ),
	.address_b ( address_S_1 ),
	.clock ( Clock_50 ),
	.data_a ( write_S_0 ),
	.data_b ( write_S_1 ),
	.wren_a ( WE_S_0 ),
	.wren_b ( WE_S_1 ),
	.q_a ( read_data_S_0 ),
	.q_b ( read_data_S_1 )
	);
	
	
//counter logic 
logic [17:0]read_address_PRE_IDCT;
// 320*(8*(RB)+(ri) + 8*(CB)+ci)

// row index = lsb for sample counter counts up to 7 // here you can add the Y base to this equation rather than in the loops
assign read_address_PRE_IDCT = (((row_index + (row_block << 3)) << 8) + ((row_index + (row_block << 3)) << 6)) + (col_index + (column_block << 8));

assign col_index = Sample_counter[2:0];
assign row_index = Sample_counter[5:3];

logic[2:0] row_index_DPRAM_S_Prime,col_index_DPRAM_S_Prime;
//counter logic 
logic [17:0]read_address_compute_T;
/// Compute T counters;
assign read_address_compute_T = (row_index_DPRAM_S_Prime<<3) + col_index_DPRAM_S_Prime;


// DRAM ADDRESS Sprime_counter
logic [6:0] dram_address_counter_s_prime;	

// DRAM ADDRESS T _counter
logic [7:0] dram_address_counter_T;


logic [2:0] COL_ADDRESS_T,ROW_ADDRESS_T;
logic [17:0]read_address_compute_S;

// row address increments each cycle 0-7 and col address only when row address rolls over.
assign read_address_compute_S = (ROW_ADDRESS_T<<3) + COL_ADDRESS_T;


// s counter for writing to DRAM to store S during compute T

logic [6:0]S_counter;

logic [6:0] DS_DP_S0, DS_DP_S1, DS_DP_S2, DS_DP_S3;

assign DS_DP_S0 = S_counter;
assign DS_DP_S1 = 6'd8 + S_counter;
assign DS_DP_S2 = 6'd16 + S_counter;
assign DS_DP_S3 = 6'd24 + S_counter;

always_ff @ (posedge Clock_50 or negedge Resetn) begin

	if (~Resetn) begin
	row_index_DPRAM_S_Prime<=0;
	col_index_DPRAM_S_Prime<=0;
	address_s_prime_0<=0; 
	address_s_prime_1<=0; 
	address_T_0<=0; 
	address_T_1<=0; 
	address_S_0<=0; 
	address_S_1<=0;
	write_s_prime_0<=0; 
	write_s_prime_1<=0; 
	write_T_0<=0; 
	write_T_1<=0;
	write_S_0<=0;
	write_S_1<=0;
	WE_s_prime_0<=0;
	WE_s_prime_1<=0;
	WE_T_0<=0;
	WE_T_1<=0;
	WE_S_0<=0;
	WE_S_1<=0;
	M2_done<=0;
	T_0<=0;
	T_1<=0;
	T_2<=0;
	T_2_BUF<=0;
	T_3_BUF<=0;
	//counter reset
	Sample_counter<=0;
	column_block<=0;
	row_block<=0;
	dram_address_counter_s_prime<=0;
	C_multiplier_row<=0;
	C_multiplier_column<=0;
	flag_increment_row<=0;
	dram_address_counter_T<=0;
	FS_CC_transition<=1;
	mux_counter<=0;
	ROW_ADDRESS_T<=0;
	COL_ADDRESS_T<=0;
	S_0<=0;
	S_1<=0;
	S_2<=0;
	S_3<=0;
	S_2_BUF<=0; 
	S_3_BUF<=0;
	
	end else begin

// READ FIRST 3 S PRIME VALUES 
	case (M2_state)
		
		S_IDLE_M2: begin
		M2_state<= S_IDLE_M2;
		if (M2_start == 1'b1) begin
		M2_state<= S_LEADIN_Fs_0;
		end

		end

		
		S_LEADIN_Fs_0: begin
		//Prepare read S'00


		SRAM_address<= read_address_PRE_IDCT +Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;


		M2_state<=S_LEADIN_Fs_1;
		end

		S_LEADIN_Fs_1: begin
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;

		M2_state<=S_LEADIN_Fs_2;
		end

		S_LEADIN_Fs_2: begin
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;

		M2_state<=S_LEADIN_Fs_3;

		end

		// READ AND STORE ALL 64 values into DP RAM FIRST VALUE AVAILABLE HERE

		S_LEADIN_Fs_3: begin

		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;

		//fill in S00 to location 0 on DPRAM 0
		address_s_prime_0 <=dram_address_counter_s_prime;
		dram_address_counter_s_prime<= dram_address_counter_s_prime+1'd1;
		write_s_prime_0<= SRAM_read_data;
		WE_s_prime_0<=1'd1;

		M2_state<=S_LEADIN_CC_Fs;

		end

		S_LEADIN_CC_Fs: begin

		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;

		//fill in S00 to location 0 on DPRAM 0
		address_s_prime_0 <=dram_address_counter_s_prime;
		dram_address_counter_s_prime<= dram_address_counter_s_prime+1'd1;
		write_s_prime_0<= SRAM_read_data;
		WE_s_prime_0<=1'd1;


		if(Sample_counter == 7'd63) begin 
		M2_state<=S_LEADOUT_Fs_0;
		WE_s_prime_0<= 1'd0;
		end
		else M2_state<=S_LEADIN_CC_Fs;

		end


		/// send last 2/3 values from SRAM read into DP memory

		S_LEADOUT_Fs_0: begin

		//fill in S75/Y2245 to location 0 on DPRAM 0
		address_s_prime_0 <=dram_address_counter_s_prime;
		dram_address_counter_s_prime<= dram_address_counter_s_prime+1'd1;
		write_s_prime_0<= SRAM_read_data;
		WE_s_prime_0<=1'd1;

		M2_state<=S_LEADOUT_Fs_1;

		end

		S_LEADOUT_Fs_1: begin
		//fill in S76/Y2246 to location 0 on DPRAM 0
		address_s_prime_0 <=dram_address_counter_s_prime;
		dram_address_counter_s_prime<= dram_address_counter_s_prime+1'd1;
		write_s_prime_0<= SRAM_read_data;
		WE_s_prime_0<=1'd1;


		M2_state<=S_LEADOUT_Fs_2;
		end

		S_LEADOUT_Fs_2: begin
		//fill in S77/Y2247 to location 0 on DPRAM 0
		address_s_prime_0 <=dram_address_counter_s_prime;
		write_s_prime_0<= SRAM_read_data;
		WE_s_prime_0<=1'd1;
		// reach 64 and reset to zero and also reset DPRAM for S' to prepare for CT reads starting at zero
		Sample_counter<=0;
		dram_address_counter_s_prime<=0;
		C_multiplier_row<= 0;
		M2_state<=S_LEADIN_CT_0;
		end


		S_LEADIN_CT_0: begin
		
		address_s_prime_0 <=read_address_compute_T+dram_address_counter_s_prime;
		//dram_address_counter_s_prime<= dram_address_counter_s_prime+1'd1;
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		// column must increment 
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		// column must increment 
		
		// increment row/column -> in this case would be?
		C_multiplier_row<= C_multiplier_row;
		M2_state<= S_LEADIN_CT_0_0;
		
		end
		
		S_LEADIN_CT_0_0: begin
		
		address_s_prime_0 <=read_address_compute_T;
		
		// column must increment 
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		// increment row/column -> in this case would be?
		C_multiplier_row<= C_multiplier_row;

		
		M2_state<= S_LEADIN_CT_1;
		end
		
		
		S_LEADIN_CT_1: begin
		address_s_prime_0 <=read_address_compute_T;
		
		
		// column must increment 
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		
		
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		
		mux_counter<= mux_counter+1'd1;
		// once read one column then update C index
		
		C_multiplier_row<= C_multiplier_row+1'd1;
		
		M2_state<= S_LEADIN_CT_2;
		
		end

		S_LEADIN_CT_2: begin

		
		// column must increment 
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		
		
		address_s_prime_0 <=read_address_compute_T;
		
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		
		mux_counter<= mux_counter+1'd1;
		// once read one column then update C index
		
		C_multiplier_row<= C_multiplier_row+1'd1;
		//  fill in T values into locaitons
		T_0<= Mult_M2_result_0;
		T_1<= Mult_M2_result_1;
		T_2<= Mult_M2_result_2;
		T_3<= Mult_M2_result_3;
		
		
		
		
		M2_state<= S_LEADIN_CT_3;
		end
		
		
		S_LEADIN_CT_3: begin
		
		
		
		// column must increment 
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		
		address_s_prime_0 <=read_address_compute_T;
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		
		mux_counter<= mux_counter+1'd1;
		// once read one column then update C index
		
		C_multiplier_row<= C_multiplier_row+1'd1;
		//  fill in T values into locaitons
		T_0<= T_0+ Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		
		
		
		
		
		
		
		
		
		
	
		
		address_s_prime_0 <=read_address_compute_T;
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		// once read one column then update C index
		
		C_multiplier_row<= C_multiplier_row+1'd1;
			//  fill in T values into locaitons
		T_0<= T_0+ Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		M2_state<= S_LEADIN_CT_4;
		
		end
		S_LEADIN_CT_4: begin
		
		
		
		
		// column must increment 
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		
		address_s_prime_0 <=read_address_compute_T;
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		// once read one column then update C index
		
		C_multiplier_row<= C_multiplier_row+1'd1;
			//  fill in T values into locaitons
		T_0<= T_0+ Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		
		M2_state<= S_LEADIN_CT_5;
		end 
		S_LEADIN_CT_5: begin
		
		
		// column must increment 
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		address_s_prime_0 <=read_address_compute_T;
		
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		// once read one column then update C index
		
		C_multiplier_row<= C_multiplier_row+1'd1;
		//  fill in T values into locaitons
		T_0<= T_0+ Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		
		
		
		
		
		
		
		
		
		
		M2_state<= S_LEADIN_CT_6;
		end 
		
		S_LEADIN_CT_6: begin
		
		
		// column must increment 
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		
		
		address_s_prime_0 <=read_address_compute_T;
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		// once read one column then update C index
		
		C_multiplier_row<= C_multiplier_row+1'd1;
			//  fill in T values into locaitons
		T_0<= T_0+ Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		M2_state<= S_LEADIN_CT_7;
		end 
		S_LEADIN_CT_7: begin
		
		
		// RESET TO ZERO IN CT_7 from lead in case.
		// column must increment 
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		
		address_s_prime_0 <=read_address_compute_T;
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		// once read one column then update C index
		
		C_multiplier_row<= C_multiplier_row+1'd1;
			//  fill in T values into locaitons
		T_0<= T_0+ Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		M2_state<= S_LEADIN_CT_8;
		end 
		S_LEADIN_CT_8: begin
		
		
		// column must increment 
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		
		address_s_prime_0 <=read_address_compute_T;	
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		// once read one column then update C index
		
	
		// RESET TO ZERO
		C_multiplier_row<= 0;
		//  fill in T values into locaitons
			//  fill in T values into locaitons
		T_0<= T_0+ Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		if (FS_CC_transition==1)C_multiplier_column<=6'd4;
		FS_CC_transition<=0;
		if (c_index_3 == 16'd59) FS_CC_transition<=1;
		
		M2_state<= S_CC_CT_0;
		end 
		
		
		
		
		/// COMMON CASE FOR COMPUTE T BEGINS HERE?
		S_CC_CT_0: begin
		
		
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		
		address_s_prime_0 <=read_address_compute_T;
		Sample_counter<= Sample_counter+1'd1; 
		// each cycle column counter is either 0 or 4
		//need to be changed
		
//		if (c_index_3 == 16'd59) C_multiplier_column<=6'd4;
//		else C_multiplier_column<=6'd0;
		 
		 
		M2_state<= S_CC_CT_1;
		if (dram_address_counter_T == 16'd64) M2_state<=S_CC_CT_LO_0;	
		
		flag_increment_row <= ~flag_increment_row;
		
		C_multiplier_row <= C_multiplier_row+1;
		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		//  READY HERE
		T_0<= T_0+Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		
		
		
		
		end

		S_CC_CT_1: begin
		
		
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		
		address_s_prime_0 <=read_address_compute_T;
		
		Sample_counter<= Sample_counter+1'd1; 
//		WE_s_prime_0<=1'd0;
//		
//		
//		
//		// write to DPRAM_T write 2 values at once
//		dram_address_counter_T<= dram_address_counter_T+1'd1;
//		address_T_0<=dram_address_counter_T;
//		address_T_1<=dram_address_counter_T+1'd1;
//		write_T_0<=T_0;
//		write_T_1<=T_1;
//		WE_T_0<=1'd1;
//		WE_T_1<=1'd1;
		
			
		address_s_prime_0 <=read_address_compute_T+dram_address_counter_s_prime;
		//dram_address_counter_s_prime<= dram_address_counter_s_prime+1'd1;
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		// write to DPRAM_T write 2 values at once COUNTER GOES UP BY +2
		dram_address_counter_T<= dram_address_counter_T+2'd2;
		
		C_multiplier_row <= C_multiplier_row+1;
	
		address_T_0<=dram_address_counter_T;
		address_T_1<=dram_address_counter_T+1'd1;
		write_T_0<=T_0>>>8;
		write_T_1<=T_1>>>8;
		WE_T_0<=1'd1;
		WE_T_1<=1'd1;
		
		// BUFFER VALUES FOR NEXT WRITE BUT ALSO COMPUTE NEW VALUES AT THE SAME TIME
		T_2_BUF<= T_2;
		T_3_BUF<= T_3;
	
		
		
		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		//  brand new
		T_0<= Mult_M2_result_0;
		T_1<= Mult_M2_result_1;
		T_2<= Mult_M2_result_2;
		T_3<= Mult_M2_result_3;
		
		
		M2_state<= S_CC_CT_2;
		
		end
		S_CC_CT_2: begin
		
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		
		address_s_prime_0 <=read_address_compute_T;
		//dram_address_counter_s_prime<= dram_address_counter_s_prime+1'd1;
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		C_multiplier_row <= C_multiplier_row+1;
		// write to DPRAM_T write 2 values at once
		dram_address_counter_T<= dram_address_counter_T+2'd2;
		address_T_0<=dram_address_counter_T;
		address_T_1<=dram_address_counter_T+1'd1;
		write_T_0<=T_2_BUF>>>8;
		write_T_1<=T_3_BUF>>>8;
		WE_T_0<=1'd1;
		WE_T_1<=1'd1;
		

		
		
		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		
		mux_counter<= mux_counter+1'd1;

		T_0<= T_0+Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		
		M2_state<= S_CC_CT_3;
		end 
		S_CC_CT_3: begin
		
		
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		// ALWAYS AFTER WRITING RESET THE WE EN TO 0 TO ENSURE NO CORRUPTION 
		WE_T_0<=1'd0;
		WE_T_1<=1'd0;
		
		C_multiplier_row <= C_multiplier_row+1;
		address_s_prime_0 <=read_address_compute_T;
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
				
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		
		mux_counter<= mux_counter+1'd1;

		T_0<= T_0+Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		M2_state<= S_CC_CT_4;
		end
		S_CC_CT_4: begin
		
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		// ALWAYS AFTER WRITING RESET THE WE EN TO 0 TO ENSURE NO CORRUPTION 
		WE_T_0<=1'd0;
		WE_T_1<=1'd0;
		
		
		address_s_prime_0 <=read_address_compute_T;
		
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		C_multiplier_row <= C_multiplier_row+1;		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		
		mux_counter<= mux_counter+1'd1;

		T_0<= T_0+Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		
		
		M2_state<= S_CC_CT_5;
		end
		S_CC_CT_5: begin
		
		
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;
		// ALWAYS AFTER WRITING RESET THE WE EN TO 0 TO ENSURE NO CORRUPTION 
		WE_T_0<=1'd0;
		WE_T_1<=1'd0;
		
		
		address_s_prime_0 <=read_address_compute_T;
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		C_multiplier_row <= C_multiplier_row+1;
				
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		
		mux_counter<= mux_counter+1'd1;

		T_0<= T_0+Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
			//special case
		//logic for incrementing row counter for C
		if (flag_increment_row==1'b1)begin
		row_index_DPRAM_S_Prime<= row_index_DPRAM_S_Prime+1'd1;	
		end
		
		M2_state<= S_CC_CT_6;
		end
		S_CC_CT_6: begin
		
		
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;	
		// ALWAYS AFTER WRITING RESET THE WE EN TO 0 TO ENSURE NO CORRUPTION 
		WE_T_0<=1'd0;
		WE_T_1<=1'd0;
		
		
		address_s_prime_0 <=read_address_compute_T;
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		C_multiplier_row <= C_multiplier_row+1;		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		
		mux_counter<= mux_counter+1'd1;

		T_0<= T_0+Mult_M2_result_0;
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		
	
		
		
		M2_state<= S_CC_CT_7;
		end
		S_CC_CT_7: begin
		
		col_index_DPRAM_S_Prime<= col_index_DPRAM_S_Prime+1'd1;	
		
		// ALWAYS AFTER WRITING RESET THE WE EN TO 0 TO ENSURE NO CORRUPTION 
		WE_T_0<=1'd0;
		WE_T_1<=1'd0;
		
		
		address_s_prime_0 <=read_address_compute_T;
		
		Sample_counter<= Sample_counter+1'd1; 
		WE_s_prime_0<=1'd0;
		
		
		C_multiplier_row <= C_multiplier_row+1;		
		//MULTIPLIERS
		// c row c column
		Mult_M2_op_0_1<= read_data_s_prime_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_s_prime_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_s_prime_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_s_prime_0;
		Mult_M2_op_3_2<=C3;
		
		mux_counter<= mux_counter+1'd1;

		T_0<= T_0+Mult_M2_result_0; 
		T_1<= T_1+Mult_M2_result_1;
		T_2<= T_2+Mult_M2_result_2;
		T_3<= T_3+Mult_M2_result_3;
		
		//logic for incrementing row counter for C
		if (flag_increment_row==1'b1)begin
		C_multiplier_row <= C_multiplier_row+1;
		//row_index_DPRAM_S_Prime<= row_index_DPRAM_S_Prime+1'd1;	
		end
		else C_multiplier_row <= C_multiplier_row;
	

		if (c_index_3 == 16'd59) C_multiplier_column<=6'd4;
		else C_multiplier_column<=6'd0;
	
		M2_state<= S_CC_CT_0;	
		
		// how do you come out of this state
		
		// 
		end
		S_CC_CT_LO_0: begin
		
		// 2 LEAD OUT CASES FOR WRITE T FOR LAST 4 T VALUES ...
			// write to DPRAM_T write 2 values at once
		dram_address_counter_T<= dram_address_counter_T+2'd2;
		address_T_0<=dram_address_counter_T;
		address_T_1<=dram_address_counter_T+1'd1;
		//note these should be T2/T3 if it makes sense
		write_T_0<=T_2>>>8;
		write_T_1<=T_3>>>8;
		WE_T_0<=1'd1;
		WE_T_1<=1'd1;
		
		M2_state<= S_CC_CT_LO_1;
		end
		S_CC_CT_LO_1: begin
		
		//reset mux_counter
		mux_counter<=0;
		WE_T_0<=1'd0;
		WE_T_1<=1'd0;
		Sample_counter<=0;
		//M2_done<=1;
		
		// to prepare for next T
		dram_address_counter_T<=0;
		M2_state<= S_CS_FS_LI_0;
		
		//IMPORTANT UPDATE ROW COUNTER OR COLUMN BLOCK
		row_block <= row_block+1'd1;
		end
		
		S_CS_FS_LI_0: begin
		
		///// Fetch S'
		
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		/// read first T values from DP RAM
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		M2_state<= S_CS_FS_LI_1;
		
		
		/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		
		
		
		end
		
		S_CS_FS_LI_1: begin
		
		M2_state<= S_CS_FS_LI_2;
		end
		
		S_CS_FS_LI_2: begin
		
		/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		
		
		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		M2_state<= S_CS_FS_LI_3;
		
		// fetch s'
			/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		//addtion BRAND NEW
		S_0 <= Mult_M2_result_0;
		S_1 <= Mult_M2_result_1;
		S_2 <= Mult_M2_result_2;
		S_3 <= Mult_M2_result_3;
		
		end
		
		S_CS_FS_LI_3: begin
			// fetch s'
			/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		//addtion BRAND NEW
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
		
		M2_state<= S_CS_FS_LI_4;
		end
		
		S_CS_FS_LI_4: begin
		
				// fetch s'
			/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		//addtion BRAND NEW
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
		
		
		
		
		
		M2_state<= S_CS_FS_LI_5;
		end
		S_CS_FS_LI_5: begin
		
				// fetch s'
			/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		//addtion BRAND NEW
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
		
		
		M2_state<= S_CS_FS_LI_6;
		end
		S_CS_FS_LI_6: begin
		
				// fetch s'
			/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		//addtion BRAND NEW
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
		
		
		M2_state<= S_CS_FS_LI_7;
		end
		S_CS_FS_LI_7: begin
		
				// fetch s'
			/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		//addtion BRAND NEW
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
		
		
		M2_state<= S_CS_FS_LI_8;
		
		
		
		
		
		
		
		end
		S_CS_FS_LI_8: begin
		
				// fetch s'
			/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		//addtion 
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
	
		M2_state<= S_CS_FS_CC_0;
		end
		
		S_CS_FS_CC_0: begin
		
		
				// fetch s'
			/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		//addtion 
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
		
		
		M2_state<= S_CS_FS_CC_1;
		
		
		
		end
		
		S_CS_FS_CC_1: begin
		
		
		// fetch s'
		/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		//addtion new 
		S_0 <= Mult_M2_result_0;
		S_1 <= Mult_M2_result_1;
		S_2 <= Mult_M2_result_2;
		S_3 <= Mult_M2_result_3;
		
		
		//buffer values
		
		S_3_BUF<= S_3;
		S_2_BUF<=S_2;
		
		
		// write to DP ram 
		address_S_0<=DS_DP_S0;
		
		address_S_1<=DS_DP_S1; 
		write_S_0 <=S_0;
		write_S_1 <=S_1;
		// set to zero after writing
		WE_S_0 <= 1'b1;
		WE_S_1 <=1'b1;
		
		
		
		
		
		
		
		
		M2_state<= S_CS_FS_CC_2;
		end
		
		S_CS_FS_CC_2: begin
		
		
				
		// fetch s'
		/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
		
		
		
	
		// write to DP ram 
		address_S_0<=DS_DP_S2;
		
		address_S_1<=DS_DP_S3; 
		write_S_0 <=S_2_BUF;
		write_S_1 <=S_3_BUF;
		// set to zero after writing
		WE_S_0 <= 1'b1;
		WE_S_1 <=1'b1;
		
		// update counter after last here
		S_counter <= S_counter+1'd1;
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		M2_state<= S_CS_FS_CC_3;
		end
		
		S_CS_FS_CC_3: begin
		
		WE_S_0 <= 1'b0;
		WE_S_1 <=1'b0;
		
		// fetch s'
		/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
		
		
		
		
		
		
		M2_state<= S_CS_FS_CC_4;
		end
		
		S_CS_FS_CC_4: begin
		
		
		// fetch s'
		/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
		
		
		
		
		
		
		
		
		
		
		
		M2_state<= S_CS_FS_CC_5;
		end
		
		S_CS_FS_CC_5: begin
		
		// fetch s'
		/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		M2_state<= S_CS_FS_CC_6;
		end
		S_CS_FS_CC_6: begin
		
		
		// fetch s'
		/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		M2_state<= S_CS_FS_CC_7;
		end
		
		S_CS_FS_CC_7: begin
		
		
		// fetch s'
		/// Fetch S'
		SRAM_address<= read_address_PRE_IDCT+Y_base_address;
		Sample_counter<= Sample_counter+1'd1; 
		SRAM_we_n<=1;
		
		
		

		/// Compute S
		ROW_ADDRESS_T<=ROW_ADDRESS_T+1'd1;
		COL_ADDRESS_T<=COL_ADDRESS_T+1'd1;
		address_T_0<= read_address_compute_S;
		WE_T_0 <=0;
		
		// c row c column
		Mult_M2_op_0_1<= read_data_T_0;
		Mult_M2_op_0_2<=C0;
		Mult_M2_op_1_1<=read_data_T_0;
		Mult_M2_op_1_2<=C1;
		Mult_M2_op_2_1<=read_data_T_0;
		Mult_M2_op_2_2<=C2;
		Mult_M2_op_3_1<=read_data_T_0;
		Mult_M2_op_3_2<=C3;
		mux_counter<= mux_counter+1'd1;
		
		S_0 <= S_0+Mult_M2_result_0;
		S_1 <= S_1+Mult_M2_result_1;
		S_2 <= S_2+Mult_M2_result_2;
		S_3 <= S_3+Mult_M2_result_3;
		
		
		if (Sample_counter == 8'd62) M2_state<=S_CS_FS_LO_0;
		
		M2_state<= S_CS_FS_CC_0;
		end
		
		
		S_CS_FS_LO_0: begin
		
		M2_state<= S_CS_FS_LO_1;
		end
		
		
		S_CS_FS_LO_1: begin
		M2_done<=1;
		M2_state<= S_IDLE_M2;
		end
		
	default: M2_state<= S_IDLE_M2;
	endcase
	end
	
end

assign c_index_0 =  mux_counter;
assign c_index_1 =  mux_counter;
assign c_index_2 = mux_counter;
assign c_index_3 =  mux_counter;
		

		
//mux 0
always_comb begin
	case(c_index_0)
	
	0: C0 = 32'sd1448;   //C00
	1: C0 = 32'sd2008;   //C10
	2: C0 = 32'sd1892;   //C20
	3: C0 = 32'sd1702;   //C30
	4: C0 = 32'sd1448;   //C40
	5: C0 = 32'sd1137;   //C50
	6: C0 = 32'sd783;    //C60
	7: C0 = 32'sd399;    //C70
	8: C0 = 32'sd1448;   //C04
	9: C0 = -32'sd399;   //C14
	10:  C0 = -32'sd1892;  //C24
	11: C0 = 32'sd1137;   //C34
	12: C0 = 32'sd1448;   //C44
	13: C0 = -32'sd1702;  //C54
	14:	C0 = -32'sd783;   //C64
	15: C0 = 32'sd2008;   //C74
	
	default: C0 = 32'sd1448;   
endcase
end

//mux 0
always_comb begin
	case(c_index_1)
	
	0: C1 = 32'sd1448;   //C01
	1: C1 = 32'sd1702;   //C11
	2: C1 = 32'sd783;    //C21
	3: C1 = -32'sd399;   //C31
	4: C1 = -32'sd1448;  //C41
	5: C1 = -32'sd2008;  //C51
	6: C1 = -32'sd1892;  //C61
	7: C1 = -32'sd1137;  //C71
	8: C1 = 32'sd1448;   //C05
	9: C1 = -32'sd1137;  //C15
	10: C1 = -32'sd783;   //C25
	11: C1 = 32'sd2008;   //C35
	12: C1= -32'sd1448;  //C45
	13: C1 = -32'sd399;   //C55
	14: C1 = 32'sd1892;   //C65
	15: C1 = -32'sd1702;  //C75
	default: C1 = 32'sd1448; 
	endcase
	
end

//mux 0
always_comb begin
	case(c_index_2)
	
	0: C2 = 32'sd1448;   //C02
	1: C2 = 32'sd1137;   //C12
	2: C2 = -32'sd783;   //C22
	3: C2 = -32'sd2008;  //C32
	4: C2 = -32'sd1448;  //C42
	5: C2 = 32'sd399;    //C52
	6: C2 = 32'sd1892;   //C62
	7: C2 = 32'sd1702;   //C72
	8: C2 = 32'sd1448;   //C06
	9: C2 = -32'sd1702;  //C16
	10: C2 = 32'sd783;    //C26
	11:  C2 = 32'sd399;    //C36
	12: C2 = -32'sd1448;  //C46
	13: C2 = 32'sd2008;   //C56
	14: C2 = -32'sd1892;  //C66
	15: C2 = 32'sd1137;   //C76
	default : C2 = 32'sd1448;
	endcase
	 
end

//mux 0
always_comb begin
	case(c_index_3)
	
	0: C3 = 32'sd1448;   //C03
	1: C3 = 32'sd399;    //C13
	2: C3 = -32'sd1892;  //C23
	3: C3 = -32'sd1137;  //C33
	4: C3 = 32'sd1448;   //C43
	5: C3 = 32'sd1702;   //C53
	6: C3 = -32'sd783;   //C63
	7: C3 = -32'sd2008;  //C73
	8: C3 = 32'sd1448;   //C07
	9: C3 = -32'sd2008;  //C17
	10: C3 = 32'sd1892;   //C27
	11: C3 = -32'sd1702;  //C37
	12: C3 = 32'sd1448;   //C47
	13: C3 = -32'sd1137;  //C57
	14: C3= 32'sd783;    //C67
	15: C3 = -32'sd399;   //C77
	default: C3 = 32'sd1448;
	endcase
	 
end




//multiplioers
assign Mult_M2_result_long_0 = Mult_M2_op_0_1 * Mult_M2_op_0_2;
assign Mult_M2_result_0 = Mult_M2_result_long_0[31:0];

assign Mult_M2_result_long_1 = Mult_M2_op_1_1 * Mult_M2_op_1_2;
assign Mult_M2_result_1 = Mult_M2_result_long_1[31:0];

assign Mult_M2_result_long_2 = Mult_M2_op_2_1 * Mult_M2_op_2_2;
assign Mult_M2_result_2 = Mult_M2_result_long_2[31:0];

assign Mult_M2_result_long_3 = Mult_M2_op_3_1 * Mult_M2_op_3_2;
assign Mult_M2_result_3 = Mult_M2_result_long_3[31:0];

 
 
endmodule 